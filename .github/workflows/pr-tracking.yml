# Updates the "Open PRs for Prod" GitHub issue with a single table:
# PR | Author | Merged to Main | Short Commit (sorted by date)
name: Prod PR Tracking

on:
  push:
    branches:
      - main
      - prod
  workflow_dispatch:
    inputs:
      prod_branch:
        description: 'Prod branch to scan for main PR references'
        required: false
        default: 'prod'

env:
  PROD_BRANCH: 'prod'
  ISSUE_TITLE: 'Open PRs for Prod'
  MAIN_PR_LIMIT: 150

jobs:
  update-preprod-pr-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set prod branch
        id: set_branch
        run: |
          if [[ -n "${{ github.event.inputs.prod_branch }}" ]]; then
            echo "branch=${{ github.event.inputs.prod_branch }}" >> $GITHUB_OUTPUT
          else
            echo "branch=${{ env.PROD_BRANCH }}" >> $GITHUB_OUTPUT
          fi

      - name: Fetch prod branch
        run: git fetch origin ${{ steps.set_branch.outputs.branch }} || true

      - name: Get merged PR numbers in prod
        run: |
          if git rev-parse origin/${{ steps.set_branch.outputs.branch }} >/dev/null 2>&1; then
            git log origin/${{ steps.set_branch.outputs.branch }} --pretty=%B \
              | sed -nE "s/.*\(#([0-9]+)\).*/\1/p; s/.*[Pp]ull request #([0-9]+).*/\1/p" \
              | sort -n -u > prod_pr_numbers.txt
          else
            : > prod_pr_numbers.txt
          fi

      - name: Fetch merged PRs to main and prod PR refs, then update issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueTitle = process.env.ISSUE_TITLE || 'Open PRs for Prod';
            const mainPrLimit = parseInt(process.env.MAIN_PR_LIMIT || '150', 10);
            const { owner, repo } = context.repo;
            const fs = require('fs');
            const path = require('path');

            // PR numbers already present on prod (from previous step)
            const prodPrNumbersPath = path.join(process.env.GITHUB_WORKSPACE, 'prod_pr_numbers.txt');
            const prodPrNumbersRaw = fs.existsSync(prodPrNumbersPath)
              ? fs.readFileSync(prodPrNumbersPath, 'utf8')
              : '';
            const prodPrNumberSet = new Set(prodPrNumbersRaw.trim().split(/\s+/).filter(Boolean));
            console.log(`Found ${prodPrNumberSet.size} PR numbers on prod`);

            function formatDDMMYYYY(isoDate) {
              if (!isoDate) return '-';
              const d = new Date(isoDate);
              const day = String(d.getDate()).padStart(2, '0');
              const month = String(d.getMonth() + 1).padStart(2, '0');
              const year = d.getFullYear();
              return `${day}-${month}-${year}`;
            }
            function fetchMergedPrs(baseBranch, limit) {
              const merged = [];
              let page = 1;
              const perPage = 100;
              return (async () => {
                while (true) {
                  const { data } = await github.rest.pulls.list({
                    owner,
                    repo,
                    state: 'closed',
                    base: baseBranch,
                    sort: 'updated',
                    direction: 'desc',
                    per_page: perPage,
                    page
                  });
                  const mergedPage = data.filter(pr => pr.merged_at != null);
                  merged.push(...mergedPage);
                  if (mergedPage.length < perPage || merged.length >= limit) break;
                  page++;
                }
                return merged
                  .sort((a, b) => new Date(b.merged_at) - new Date(a.merged_at))
                  .slice(0, limit);
              })();
            }
            function buildTable(prs, mergedToLabel) {
              let table = `| PR | Author | ${mergedToLabel} | Short Commit |\n|----|--------|----------------|---------------|\n`;
              for (const pr of prs) {
                const author = (pr.user && (pr.user.name || pr.user.login)) || '-';
                const mergedAt = formatDDMMYYYY(pr.merged_at);
                const shortCommit = (pr.merge_commit_sha || '').slice(0, 7) || '-';
                const prLink = `[PR-${pr.number}](${pr.html_url})`;
                const authorEscaped = author.replace(/\|/g, '\\|');
                table += `| ${prLink} | ${authorEscaped} | ${mergedAt} | ${shortCommit} |\n`;
              }
              return table;
            }

            // Fetch PRs merged to main, then exclude PRs already present on prod by PR number
            const mainPrs = await fetchMergedPrs('main', mainPrLimit);
            const mainPrsNotInProd = mainPrs.filter(pr => !prodPrNumberSet.has(String(pr.number)));
            console.log(`Main merged PRs: ${mainPrs.length}, remaining not in prod: ${mainPrsNotInProd.length}`);

            const table = buildTable(mainPrsNotInProd, 'Merged to Main');

            const body = [
              '## PRs merged to main (not yet in prod)',
              '',
              table,
              '',
              `_Last updated by [Prod PR Tracking](${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}) workflow._`
            ].join('\n');

            // 5) Find or create the issue
            const { data: search } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} "${issueTitle}" is:issue`
            });
            const existing = search.items.length ? search.items[0] : null;
            let issueNumber = existing ? existing.number : null;

            if (issueNumber) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body
              });
              if (existing && existing.state === 'closed') {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  state: 'open'
                });
              }
              console.log('Updated issue #' + issueNumber);
            } else {
              const { data: created } = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body
              });
              issueNumber = created.number;
              console.log('Created issue #' + issueNumber);
            }
            return { issue_number: issueNumber };
        env:
          ISSUE_TITLE: 'Open PRs for Prod'
          MAIN_PR_LIMIT: '150'
